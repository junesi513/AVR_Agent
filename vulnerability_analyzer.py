#!/usr/bin/env python3
"""
취약점 분석 및 수정 Agent
Author: Assistant
Description: Java 소스코드의 취약점을 분석하고 패치를 생성하는 시스템
"""

import os
import sys
import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from abc import ABC, abstractmethod
from llm_interfaces import LLMFactory, LLMInterface

# 로깅 설정
def setup_logging():
    log_dir = Path("./log")
    log_dir.mkdir(exist_ok=True)
    
    log_file = log_dir / f"vulnerability_analyzer_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
    
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file, encoding='utf-8'),
            logging.StreamHandler(sys.stdout)
        ]
    )
    return logging.getLogger(__name__)

class VulnerabilityAnalyzer:
    """메인 취약점 분석 시스템"""
    
    def __init__(self, vuln_id: int = 1, llm_config: Optional[Dict[str, Any]] = None):
        self.vuln_id = vuln_id
        self.logger = setup_logging()
        self.source_path = Path(f"./benchmark/Java/VUL4J/VUL4J-{vuln_id}")
        self.target_path = self.source_path  # 정적 분석 대상 경로
        self.rule_dir = Path(f"./rule/VUL4J-{vuln_id}")
        self.log_dir = Path(f"./log/VUL4J-{vuln_id}")
        
        # 디렉토리 생성
        self.rule_dir.mkdir(parents=True, exist_ok=True)
        self.log_dir.mkdir(parents=True, exist_ok=True)
        
        # LLM 설정 로드
        self.llm_config = self._load_llm_config(llm_config)
        self.llm = self._initialize_llm()
        
        # 단계별 처리기 초기화
        self.ast_processor = ASTProcessor()
        self.vulnerability_detector = VulnerabilityDetector(self.llm)
        self.patch_generator = PatchGenerator(self.llm)
        
        self.logger.info(f"취약점 분석기 초기화 완료 - ID: {vuln_id}")
        if self.llm:
            self.logger.info(f"LLM 연결됨: {self.llm.__class__.__name__}")
    
    def _load_llm_config(self, llm_config: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        """LLM 설정 로드"""
        if llm_config:
            return llm_config
        
        # llm_config.json 파일에서 설정 로드
        config_file = Path("llm_config.json")
        if config_file.exists():
            try:
                with open(config_file, 'r', encoding='utf-8') as f:
                    config_data = json.load(f)
                
                # 활성화된 LLM 찾기
                for llm_cfg in config_data.get("llm_configs", []):
                    if llm_cfg.get("enabled", False):
                        return llm_cfg
                
                # 기본 LLM 사용
                default_llm_name = config_data.get("default_llm", "qwen")
                for llm_cfg in config_data.get("llm_configs", []):
                    if llm_cfg.get("name") == default_llm_name:
                        return llm_cfg
                        
            except Exception as e:
                self.logger.warning(f"LLM 설정 로드 실패: {str(e)}")
        
        # 기본 설정 반환 (Ollama/Qwen)
        return {
            "type": "ollama",
            "model": "qwen:7b", 
            "base_url": "http://localhost:11434",
            "temperature": 0.1
        }
    
    def _initialize_llm(self) -> Optional[LLMInterface]:
        """LLM 초기화"""
        try:
            llm_type = self.llm_config.get("type", "ollama")
            return LLMFactory.create_llm(llm_type, **self.llm_config)
        except Exception as e:
            self.logger.warning(f"LLM 초기화 실패: {str(e)}")
            self.logger.info("패턴 매칭 방식으로 대체")
            return None
    
    def analyze(self) -> Dict[str, Any]:
        """전체 분석 프로세스 실행"""
        try:
            self.logger.info("=== Stage 1: 사전 작업 시작 ===")
            ast_data = self.stage1_preprocessing()
            
            self.logger.info("=== Stage 2: 취약점 분석 시작 ===")
            vulnerabilities = self.stage2_vulnerability_analysis(ast_data)
            
            self.logger.info("=== Stage 3: 패치 생성 시작 ===")
            patches = self.stage3_patch_generation(vulnerabilities)
            
            result = {
                "vuln_id": self.vuln_id,
                "timestamp": datetime.now().isoformat(),
                "ast_data": ast_data,
                "vulnerabilities": vulnerabilities,
                "patches": patches,
                "status": "completed"
            }
            
            # 결과 저장
            self._save_analysis_result(result)
            
            return result
            
        except Exception as e:
            self.logger.error(f"분석 중 오류 발생: {str(e)}")
            return {"status": "error", "error": str(e)}
    
    def stage1_preprocessing(self) -> Dict[str, Any]:
        """Stage 1: AST 노드 추출 및 함수/클래스 단위 분리"""
        self.logger.info("AST 노드 추출 시작")
        
        java_files = list(self.source_path.glob("*.java"))
        if not java_files:
            raise FileNotFoundError(f"Java 파일을 찾을 수 없습니다: {self.source_path}")
        
        ast_data = {}
        for java_file in java_files:
            self.logger.info(f"파일 처리 중: {java_file.name}")
            file_ast = self.ast_processor.extract_ast(java_file)
            ast_data[java_file.name] = file_ast
        
        self.logger.info(f"AST 추출 완료 - {len(ast_data)} 파일 처리")
        return ast_data
    
    def stage2_vulnerability_analysis(self, ast_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Stage 2: 취약점 분석"""
        vulnerabilities = []
        
        for file_name, file_ast in ast_data.items():
            self.logger.info(f"취약점 분석 중: {file_name}")
            
            # 각 함수에 대해 취약점 분석
            for func_info in file_ast.get("functions", []):
                func_name = func_info["name"]
                
                # LLM 취약점 가설 생성
                hypothesis = self.vulnerability_detector.generate_hypothesis(func_info)
                
                if hypothesis:
                    # Semgrep 및 CodeQL 규칙 생성
                    semgrep_rule = self.vulnerability_detector.generate_semgrep_rule(
                        self.vuln_id, func_name, hypothesis
                    )
                    codeql_rule = self.vulnerability_detector.generate_codeql_rule(
                        self.vuln_id, func_name, hypothesis
                    )
                    
                    # 규칙 저장
                    semgrep_rule_file = self._save_rule("semgrep", self.vuln_id, func_name, semgrep_rule)
                    codeql_rule_file = self._save_rule("codeql", self.vuln_id, func_name, codeql_rule)
                    
                    # 실제 정적 분석 도구 실행
                    semgrep_results = None
                    codeql_results = None
                    
                    if semgrep_rule_file and semgrep_rule.strip():
                        self.logger.info(f"Semgrep 실행 중: {func_name}")
                        semgrep_results = self.vulnerability_detector.run_semgrep_analysis(
                            str(semgrep_rule_file), 
                            str(self.target_path)
                        )
                    
                    if codeql_rule_file and codeql_rule.strip():
                        self.logger.info(f"CodeQL 실행 중: {func_name}")
                        codeql_results = self.vulnerability_detector.run_codeql_analysis(
                            str(codeql_rule_file),
                            str(self.target_path)
                        )
                    
                    confirmed = self._is_vulnerability_confirmed(semgrep_results, codeql_results)
                    
                    vulnerability = {
                        "file": file_name,
                        "function": func_name,
                        "hypothesis": hypothesis,
                        "semgrep_rule": semgrep_rule,
                        "codeql_rule": codeql_rule,
                        "severity": hypothesis.get("severity", "medium"),
                        "semgrep_results": semgrep_results,
                        "codeql_results": codeql_results,
                        "confirmed": confirmed
                    }
                    
                    # 검증된 취약점만 결과에 포함 (개발/테스트시에는 모두 포함)
                    vulnerabilities.append(vulnerability)
        
        self.logger.info(f"취약점 분석 완료 - {len(vulnerabilities)}개 발견")
        return vulnerabilities
    
    def stage3_patch_generation(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Stage 3: 패치 생성"""
        patches = []
        
        for vuln in vulnerabilities:
            self.logger.info(f"패치 생성 중: {vuln['function']}")
            
            patch = self.patch_generator.generate_patch(vuln)
            if patch:
                patches.append(patch)
        
        self.logger.info(f"패치 생성 완료 - {len(patches)}개 생성")
        return patches
    
    def _save_rule(self, rule_type: str, vuln_id: int, func_name: str, rule_content: str):
        """규칙 파일 저장"""
        if not rule_content.strip():
            return None
        
        # 디렉토리가 존재하지 않으면 생성
        self.rule_dir.mkdir(parents=True, exist_ok=True)
            
        rule_file = self.rule_dir / f"{rule_type}{vuln_id}-{func_name}"
        with open(rule_file, 'w', encoding='utf-8') as f:
            f.write(rule_content)
        self.logger.info(f"규칙 저장됨: {rule_file}")
        return rule_file
    
    def _is_vulnerability_confirmed(self, semgrep_results: Dict[str, Any], codeql_results: Dict[str, Any]) -> bool:
        """정적 분석 도구 결과를 바탕으로 취약점 확인"""
        confirmed = False
        confidence_score = 0.0
        
        # Semgrep 결과 확인
        if semgrep_results and semgrep_results.get("status") == "success":
            findings = semgrep_results.get("findings", [])
            if findings:
                confirmed = True
                confidence_score += 0.6  # Semgrep 검증시 60% 신뢰도
                self.logger.info(f"Semgrep 검증 성공: {len(findings)}개 발견")
        
        # CodeQL 결과 확인  
        if codeql_results and codeql_results.get("status") == "success":
            findings = codeql_results.get("findings", [])
            if findings and len(findings) > 1:  # CSV 헤더 제외
                confirmed = True
                confidence_score += 0.4  # CodeQL 검증시 40% 신뢰도
                self.logger.info(f"CodeQL 검증 성공: {len(findings)-1}개 발견")
        
        # 검증 실패 로그
        if not confirmed:
            self.logger.warning("정적 분석 도구 검증 실패 - 취약점 미확인")
            
        return confirmed
    
    def _save_analysis_result(self, result: Dict[str, Any]):
        """분석 결과 저장"""
        # 디렉토리가 존재하지 않으면 생성
        self.log_dir.mkdir(parents=True, exist_ok=True)
        
        result_file = self.log_dir / f"analysis_result_{self.vuln_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(result_file, 'w', encoding='utf-8') as f:
            json.dump(result, f, indent=2, ensure_ascii=False)
        self.logger.info(f"분석 결과 저장됨: {result_file}")


class ASTProcessor:
    """AST 처리 클래스"""
    
    def extract_ast(self, java_file: Path) -> Dict[str, Any]:
        """Java 파일에서 AST 추출 및 함수/클래스 분리"""
        with open(java_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # 간단한 Java 파싱 (실제로는 JavaParser 등을 사용할 수 있음)
        ast_data = {
            "file_path": str(java_file),
            "content": content,
            "classes": self._extract_classes(content),
            "functions": self._extract_methods(content),
            "imports": self._extract_imports(content)
        }
        
        return ast_data
    
    def _extract_classes(self, content: str) -> List[Dict[str, Any]]:
        """클래스 정보 추출"""
        classes = []
        lines = content.split('\n')
        
        for i, line in enumerate(lines):
            stripped = line.strip()
            if stripped.startswith('public class ') or stripped.startswith('class '):
                class_name = stripped.split()[2] if 'public' in stripped else stripped.split()[1]
                if '{' in class_name:
                    class_name = class_name.split('{')[0]
                
                classes.append({
                    "name": class_name,
                    "line": i + 1,
                    "modifiers": ["public"] if "public" in stripped else [],
                    "interfaces": self._extract_implements(stripped)
                })
        
        return classes
    
    def _extract_methods(self, content: str) -> List[Dict[str, Any]]:
        """메소드 정보 추출 (실제 구현 코드 포함)"""
        methods = []
        lines = content.split('\n')
        
        i = 0
        while i < len(lines):
            stripped = lines[i].strip()
            
            # 어노테이션 건너뛰기
            if stripped.startswith('@'):
                i += 1
                continue
            
            # 메소드 시그니처 패턴 (더 정확하게)
            is_method_line = (
                # 접근 제한자로 시작하는 메소드
                (stripped.startswith('public ') or stripped.startswith('private ') or 
                 stripped.startswith('protected ') or stripped.startswith('static ')) and
                '(' in stripped and
                not stripped.strip().endswith(';') and  # 메소드 선언이 아닌 정의
                not '=' in stripped.split('(')[0] and  # 대입문이 아님
                not stripped.startswith('if ') and     # if문이 아님
                not stripped.startswith('for ') and    # for문이 아님
                not stripped.startswith('while ') and  # while문이 아님
                not '.' in stripped.split('(')[0].split()[-1] and  # 메소드 호출이 아님
                not 'new ' in stripped  # 생성자 호출이 아님
            )
            
            if is_method_line:
                # 메소드 시그니처와 본문을 분리해서 처리
                signature_lines = [stripped]
                j = i + 1
                
                # 시그니처 완성까지 수집 ('{' 또는 'throws' 전까지)
                while j < len(lines):
                    next_line = lines[j].strip()
                    if '{' in next_line:
                        # throws가 있으면 포함
                        if 'throws' in next_line.split('{')[0]:
                            signature_lines.append(next_line.split('{')[0].strip())
                        break
                    elif 'throws' in next_line:
                        signature_lines.append(next_line)
                        j += 1
                        continue
                    elif next_line and not next_line.startswith('//'):
                        signature_lines.append(next_line)
                    j += 1
                
                # 시그니처 정리
                method_signature = ' '.join(signature_lines).strip()
                
                # 메소드 본문 추출 (j 위치부터)
                method_body = self._extract_method_body(lines, j)
                
                method_info = self._parse_method_signature(method_signature)
                if method_info and method_info.get("name"):
                    method_info["line"] = i + 1
                    method_info["body_start"] = j + 1
                    method_info["full_signature"] = method_signature
                    method_info["implementation"] = method_body  # 실제 구현 코드 추가
                    methods.append(method_info)
            
            i += 1
        
        return methods
    
    def _extract_method_body(self, lines: List[str], start_index: int) -> str:
        """메소드 본문 추출"""
        if start_index >= len(lines):
            return ""
        
        method_body_lines = []
        brace_count = 0
        started = False
        
        # start_index부터 시작해서 첫 번째 { 찾기
        for i in range(start_index, len(lines)):
            line = lines[i]
            
            # 첫 번째 { 찾기
            if '{' in line and not started:
                started = True
                # { 이후 부분부터 시작
                brace_part = line[line.find('{'):]
                brace_count += brace_part.count('{')
                brace_count -= brace_part.count('}')
                method_body_lines.append(line)
                
                if brace_count == 0:  # 메소드 끝 (한 줄 메소드)
                    break
            elif started:
                brace_count += line.count('{')
                brace_count -= line.count('}')
                method_body_lines.append(line)
                
                if brace_count == 0:  # 메소드 끝
                    break
        
        return '\n'.join(method_body_lines)
    
    def _extract_imports(self, content: str) -> List[str]:
        """import 문 추출"""
        imports = []
        for line in content.split('\n'):
            stripped = line.strip()
            if stripped.startswith('import ') and stripped.endswith(';'):
                imports.append(stripped[7:-1])  # 'import ' 제거하고 ';' 제거
        return imports
    
    def _extract_implements(self, class_line: str) -> List[str]:
        """implements 인터페이스 추출"""
        if 'implements' not in class_line:
            return []
        
        implements_part = class_line.split('implements')[1].split('{')[0]
        interfaces = [iface.strip() for iface in implements_part.split(',')]
        return interfaces
    
    def _parse_method_signature(self, signature: str) -> Optional[Dict[str, Any]]:
        """메소드 시그니처 파싱"""
        try:
            # 전처리: 개행 문자 제거, 다중 공백 정리
            signature = ' '.join(signature.split())
            
            method_info = {
                "modifiers": [],
                "return_type": None,
                "name": None,
                "parameters": []
            }
            
            # throws 절 제거 (임시)
            signature_parts = signature.split(' throws ')
            main_signature = signature_parts[0]
            
            # 괄호 위치 찾기
            paren_start = main_signature.find('(')
            if paren_start == -1:
                return None
                
            paren_end = main_signature.rfind(')')
            if paren_end == -1:
                return None
            
            # 매개변수 추출
            params_str = main_signature[paren_start + 1:paren_end]
            if params_str.strip():
                # 제네릭 타입을 고려한 매개변수 파싱
                params = []
                current_param = ""
                angle_bracket_count = 0
                
                for char in params_str:
                    if char == '<':
                        angle_bracket_count += 1
                    elif char == '>':
                        angle_bracket_count -= 1
                    elif char == ',' and angle_bracket_count == 0:
                        if current_param.strip():
                            params.append(current_param.strip())
                        current_param = ""
                        continue
                    
                    current_param += char
                
                if current_param.strip():
                    params.append(current_param.strip())
                
                method_info["parameters"] = params
            
            # 메소드 이름과 반환 타입 추출
            before_params = main_signature[:paren_start].strip()
            parts = before_params.split()
            
            if not parts:
                return None
            
            # 수정자 추출
            modifiers = ['public', 'private', 'protected', 'static', 'final', 'synchronized', 'abstract']
            i = 0
            while i < len(parts) and parts[i] in modifiers:
                method_info["modifiers"].append(parts[i])
                i += 1
            
            # 나머지 부분에서 반환 타입과 메소드 이름 추출
            remaining_parts = parts[i:]
            
            if len(remaining_parts) >= 1:
                # 마지막 부분이 메소드 이름
                method_info["name"] = remaining_parts[-1]
                
                # 그 앞 부분들이 반환 타입 (제네릭 포함)
                if len(remaining_parts) > 1:
                    method_info["return_type"] = ' '.join(remaining_parts[:-1])
                else:
                    # 생성자인 경우
                    method_info["return_type"] = None
            
            return method_info if method_info["name"] else None
            
        except Exception as e:
            return None


# LLM 인터페이스 추상 클래스
class LLMInterface(ABC):
    """LLM 인터페이스 추상 클래스"""
    
    @abstractmethod
    def generate_response(self, prompt: str, **kwargs) -> str:
        """응답 생성"""
        pass


class VulnerabilityDetector:
    """취약점 탐지 클래스"""
    
    def __init__(self, llm: Optional[LLMInterface] = None):
        self.llm = llm
    
    def generate_hypothesis(self, func_info: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """LLM을 사용한 취약점 가설 생성"""
        # 패턴 매칭 방식 우선 사용 (더 안정적)
        pattern_result = self._pattern_based_analysis(func_info)
        
        # LLM이 사용 가능한 경우 LLM 결과와 결합
        if self.llm:
            try:
                llm_result = self.llm.generate_vulnerability_hypothesis(func_info)
                if llm_result and pattern_result:
                    # 두 결과를 결합
                    combined_vulns = pattern_result["vulnerabilities"] + llm_result["vulnerabilities"]
                    pattern_result["vulnerabilities"] = combined_vulns
                    pattern_result["analysis_method"] = "pattern_matching + llm"
                elif llm_result:
                    return llm_result
            except Exception as e:
                logging.getLogger(__name__).warning(f"LLM 분석 실패, 패턴 매칭 결과만 사용: {str(e)}")
        
        return pattern_result
    
    def _pattern_based_analysis(self, func_info: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """패턴 기반 취약점 분석"""
        func_name = func_info.get("name", "unknown")
        signature = func_info.get("full_signature", "")
        
        # 일반적인 취약점 패턴 검사
        vulnerabilities = []
        
        # 1. Null Pointer Dereference 검사
        if "null" in signature.lower() or func_name.lower() in ["deserialize", "deserialze"]:
            vulnerabilities.append({
                "type": "NULL_POINTER_DEREFERENCE",
                "description": "잠재적인 Null Pointer Dereference 취약점",
                "severity": "medium",
                "confidence": 0.7
            })
        
        # 2. Type Confusion 검사
        if "cast" in signature.lower() or "unchecked" in signature.lower():
            vulnerabilities.append({
                "type": "TYPE_CONFUSION", 
                "description": "타입 캐스팅 관련 Type Confusion 취약점",
                "severity": "high",
                "confidence": 0.8
            })
        
        # 3. Deserialization 취약점 검사
        if any(keyword in func_name.lower() for keyword in ["deserialize", "parse", "decode"]):
            vulnerabilities.append({
                "type": "UNSAFE_DESERIALIZATION",
                "description": "안전하지 않은 역직렬화 취약점",
                "severity": "high", 
                "confidence": 0.9
            })
        
        if vulnerabilities:
            return {
                "function": func_name,
                "vulnerabilities": vulnerabilities,
                "analysis_method": "pattern_matching",
                "severity": max(v["severity"] for v in vulnerabilities)
            }
        
        return None
    
    def generate_semgrep_rule(self, vuln_id: int, func_name: str, hypothesis: Dict[str, Any]) -> str:
        """Semgrep 규칙 생성"""
        vulnerabilities = hypothesis.get("vulnerabilities", [])
        
        if not vulnerabilities:
            return ""
        
        # 첫 번째 취약점을 기준으로 규칙 생성
        vuln = vulnerabilities[0]
        vuln_type = vuln["type"]
        
        rule_template = f"""rules:
  - id: vuln-{vuln_id}-{func_name.lower()}
    message: {vuln["description"]}
    severity: {vuln["severity"].upper()}
    languages: [java]
    pattern-either:"""
        
        if vuln_type == "NULL_POINTER_DEREFERENCE":
            rule_template += f"""
      - pattern: |
          public $TYPE {func_name}(...) {{
            ...
            if ($VAR == null) {{
              ...
            }}
            ...
            $VAR.$METHOD(...)
            ...
          }}"""
        
        elif vuln_type == "TYPE_CONFUSION":
            rule_template += f"""
      - pattern: |
          @SuppressWarnings("unchecked")
          public $TYPE {func_name}(...) {{
            ...
            ($CAST_TYPE) $VAR
            ...
          }}"""
        
        elif vuln_type == "UNSAFE_DESERIALIZATION":
            rule_template += f"""
      - pattern: |
          public $TYPE {func_name}(...) {{
            ...
            parser.parseArray(...)
            ...
          }}"""
        
        return rule_template
    
    def generate_codeql_rule(self, vuln_id: int, func_name: str, hypothesis: Dict[str, Any]) -> str:
        """CodeQL 규칙 생성"""
        vulnerabilities = hypothesis.get("vulnerabilities", [])
        
        if not vulnerabilities:
            return ""
        
        vuln = vulnerabilities[0]
        vuln_type = vuln["type"]
        
        rule_template = f"""/**
 * @name {vuln["description"]}
 * @description Detects {vuln_type.lower().replace('_', ' ')} in {func_name}
 * @kind problem
 * @problem.severity {vuln["severity"]}
 * @id java/vuln-{vuln_id}-{func_name.lower()}
 */

import java

"""
        
        if vuln_type == "NULL_POINTER_DEREFERENCE":
            rule_template += f"""from Method m, MethodAccess ma, Variable v
where
  m.getName() = "{func_name}" and
  ma.getEnclosingCallable() = m and
  ma.getQualifier() = v.getAnAccess() and
  exists(EqualityTest eq | 
    eq.getAnOperand() = v.getAnAccess() and
    eq.getAnOperand().(NullLiteral).toString() = "null"
  )
select ma, "Potential null pointer dereference in {func_name}"
"""
        
        elif vuln_type == "TYPE_CONFUSION":
            rule_template += f"""from Method m, CastExpr cast
where
  m.getName() = "{func_name}" and
  cast.getEnclosingCallable() = m and
  m.getAnAnnotation().toString().matches("%SuppressWarnings%")
select cast, "Unsafe type cast in {func_name}"
"""
        
        elif vuln_type == "UNSAFE_DESERIALIZATION":
            rule_template += f"""from Method m, MethodAccess ma
where
  m.getName() = "{func_name}" and
  ma.getEnclosingCallable() = m and
  ma.getMethod().getName().matches("parse%")
select ma, "Unsafe deserialization in {func_name}"
"""
        
        return rule_template
    
    def run_semgrep_analysis(self, rule_file: str, target_path: str) -> Dict[str, Any]:
        """Semgrep 실행"""
        import subprocess
        import json
        import os
        
        try:
            # Semgrep 경로 찾기
            semgrep_paths = [
                "/home/user/anaconda3/envs/ace4_sijune/bin/semgrep",
                "/home/ace4_sijune/.local/bin/semgrep",
                "semgrep",
                "python3 -m semgrep"
            ]
            
            semgrep_cmd = None
            for path in semgrep_paths:
                if " " in path:  # python -m semgrep 경우
                    try:
                        result = subprocess.run(path.split() + ["--version"], 
                                              capture_output=True, text=True, timeout=10)
                        if result.returncode == 0 or "semgrep" in result.stderr.lower():
                            semgrep_cmd = path.split()
                            break
                    except:
                        continue
                else:
                    if os.path.exists(path) or subprocess.run(["which", path], 
                                                            capture_output=True).returncode == 0:
                        semgrep_cmd = [path]
                        break
            
            if not semgrep_cmd:
                return {
                    "status": "error",
                    "error": "Semgrep not found in any expected location"
                }
            
            # Semgrep 명령어 실행
            cmd = semgrep_cmd + [
                "--config", rule_file,
                "--json",
                "--no-git-ignore",
                target_path
            ]
            
            result = subprocess.run(
                cmd, 
                capture_output=True, 
                text=True, 
                timeout=60
            )
            
            if result.returncode == 0:
                # JSON 결과 파싱
                try:
                    output = json.loads(result.stdout)
                    return {
                        "status": "success",
                        "findings": output.get("results", []),
                        "errors": output.get("errors", [])
                    }
                except json.JSONDecodeError:
                    return {
                        "status": "success", 
                        "findings": [],
                        "raw_output": result.stdout
                    }
            else:
                return {
                    "status": "error",
                    "error": result.stderr,
                    "returncode": result.returncode
                }
                
        except subprocess.TimeoutExpired:
            return {
                "status": "timeout",
                "error": "Semgrep execution timed out"
            }
        except FileNotFoundError:
            return {
                "status": "error",
                "error": "Semgrep not found. Please install semgrep first."
            }
        except Exception as e:
            return {
                "status": "error", 
                "error": str(e)
            }
    
    def run_codeql_analysis(self, rule_file: str, target_path: str, database_path: str = None) -> Dict[str, Any]:
        """CodeQL 실행"""
        import subprocess
        import json
        import tempfile
        import os
        
        try:
            # CodeQL 데이터베이스가 없으면 생성
            if not database_path:
                database_path = f"./codeql_db_{os.getpid()}"
                
                # Java 프로젝트 디렉토리 확인
                java_dir = os.path.dirname(target_path)
                
                # 데이터베이스 생성
                create_cmd = [
                    "codeql", "database", "create",
                    database_path,
                    "--language=java",
                    f"--source-root={java_dir}",
                    "--search-path=/opt/codeql-repo"
                ]
                
                create_result = subprocess.run(
                    create_cmd,
                    capture_output=True,
                    text=True,
                    timeout=120
                )
                
                if create_result.returncode != 0:
                    return {
                        "status": "error",
                        "error": f"CodeQL database creation failed: {create_result.stderr}"
                    }
            
            # CodeQL 쿼리 실행
            with tempfile.NamedTemporaryFile(mode='w', suffix='.ql', delete=False) as f:
                f.write(open(rule_file, 'r').read())
                query_file = f.name
            
            try:
                cmd = [
                    "codeql", "query", "run",
                    query_file,
                    "--database", database_path,
                    "--output", f"{query_file}.bqrs",
                    "--search-path=/opt/codeql-repo"
                ]
                
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=60
                )
                
                if result.returncode == 0:
                    # BQRS 결과를 CSV로 변환
                    decode_cmd = [
                        "codeql", "bqrs", "decode",
                        f"{query_file}.bqrs",
                        "--format=csv"
                    ]
                    
                    decode_result = subprocess.run(
                        decode_cmd,
                        capture_output=True,
                        text=True
                    )
                    
                    return {
                        "status": "success",
                        "findings": decode_result.stdout.split('\n') if decode_result.returncode == 0 else [],
                        "raw_output": decode_result.stdout
                    }
                else:
                    return {
                        "status": "error",
                        "error": result.stderr,
                        "returncode": result.returncode
                    }
                    
            finally:
                # 임시 파일 정리
                try:
                    os.unlink(query_file)
                    os.unlink(f"{query_file}.bqrs")
                except:
                    pass
                    
        except subprocess.TimeoutExpired:
            return {
                "status": "timeout",
                "error": "CodeQL execution timed out"
            }
        except FileNotFoundError:
            return {
                "status": "error",
                "error": "CodeQL not found. Please install CodeQL CLI first."
            }
        except Exception as e:
            return {
                "status": "error",
                "error": str(e)
            }


class PatchGenerator:
    """패치 생성 클래스"""
    
    def __init__(self, llm: Optional[LLMInterface] = None):
        self.llm = llm
    
    def generate_patch(self, vulnerability: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """취약점에 대한 패치 생성"""
        vuln_type = vulnerability["hypothesis"]["vulnerabilities"][0]["type"]
        func_name = vulnerability["function"]
        
        patch_code = ""
        
        if vuln_type == "NULL_POINTER_DEREFERENCE":
            patch_code = f"""
// 패치: Null 검사 추가
public <T> T {func_name}(...) {{
    // Null 검사 추가
    if (parser == null) {{
        throw new IllegalArgumentException("Parser cannot be null");
    }}
    if (type == null) {{
        throw new IllegalArgumentException("Type cannot be null");
    }}
    
    // 기존 코드...
}}
"""
        
        elif vuln_type == "TYPE_CONFUSION":
            patch_code = f"""
// 패치: 안전한 타입 캐스팅
public <T> T {func_name}(...) {{
    // 타입 검증 추가
    if (value != null && !componentType.isInstance(value)) {{
        throw new ClassCastException("Invalid type cast detected");
    }}
    
    // 기존 코드...
}}
"""
        
        elif vuln_type == "UNSAFE_DESERIALIZATION":
            patch_code = f"""
// 패치: 안전한 역직렬화
public <T> T {func_name}(...) {{
    // 입력 검증 추가
    if (!isValidInputType(componentType)) {{
        throw new SecurityException("Unsafe deserialization attempt");
    }}
    
    // 기존 코드...
}}

private boolean isValidInputType(Class<?> type) {{
    // 허용된 타입 목록 검사
    return ALLOWED_TYPES.contains(type);
}}
"""
        
        return {
            "vulnerability_id": f"{vulnerability['file']}#{func_name}",
            "patch_type": vuln_type,
            "patch_code": patch_code,
            "description": f"패치 for {vuln_type} in {func_name}",
            "confidence": 0.8
        }


if __name__ == "__main__":
    # 메인 실행
    analyzer = VulnerabilityAnalyzer(vuln_id=1)
    result = analyzer.analyze()
    
    if result["status"] == "completed":
        print("✅ 취약점 분석 완료!")
        print(f"🔍 발견된 취약점: {len(result['vulnerabilities'])}개")
        print(f"🔧 생성된 패치: {len(result['patches'])}개")
    else:
        print(f"❌ 분석 실패: {result.get('error', 'Unknown error')}") 